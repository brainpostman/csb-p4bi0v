{"version":3,"sources":["Snake.js","App.js","index.js"],"names":["deepCopy","array","JSON","parse","stringify","Snake","props","useState","gridWidth","gridHeight","grid","gridState","setGridState","head","slice","snakeHead","setSnakeHead","path","snakePath","setSnakePath","keyPress","setKeyPress","snakeDirection","setSnakeDirection","food","setFood","start","setStart","loss","setLoss","score","setScore","timeoutRef","useRef","prevKeyRef","useEffect","document","addEventListener","event","key","current","checkSnakeContact","checkWallContact","newDirection","chooseDirection","newState","generateNextState","setTimeout","newHead","newPath","newFood","clearTimeout","prevGrid","prevHead","prevPath","direction","prevFood","foodEaten","handleEatFood","unshift","lastCell","prevScore","pop","cell","generateNewFood","prevDirection","arrow","every","item","index","y","Math","floor","random","x","forEach","className","onClick","gameRestart","style","gridTemplateColumns","map","itemH","indexH","itemW","indexW","flatMap","App","setGridWidth","setGridHeight","gameStart","setGameStart","initialSnakeHead","setInitialSnakeHead","initialSnakePath","setInitialSnakePath","initialFood","setInitialFood","initialGrid","setInitialGrid","errorRef","setStartingPositions","arr","width","length","height","round","i","snakePathCell","push","pathCell","Number","parseInt","type","value","onChange","target","gridArray","j","startObj","rootElement","getElementById","createRoot","render"],"mappings":"4NAIA,SAASA,EAASC,GAChB,OAAOC,KAAKC,MAAMD,KAAKE,UAAUH,GACnC,CAEe,SAASI,EAAMC,GAC5B,MAAkCC,mBAASD,EAAME,WAAU,mBAApDA,EAAS,KAChB,GAD8B,KACMD,mBAASD,EAAMG,aAAW,mBAAvDA,EAAU,KACjB,GADgC,KACEF,mBAASP,EAASM,EAAMI,QAAM,mBAAzDC,EAAS,KAAEC,EAAY,KAC9B,EAAkCL,mBAASD,EAAMO,KAAKC,SAAQ,mBAAvDC,EAAS,KAAEC,EAAY,KAC9B,EAAkCT,mBAASP,EAASM,EAAMW,OAAM,mBAAzDC,EAAS,KAAEC,EAAY,KAC9B,EAAgCZ,mBAAS,SAAQ,mBAA1Ca,EAAQ,KAAEC,EAAW,KAC5B,EAA4Cd,mBAAS,MAAK,mBAAnDe,EAAc,KAAEC,EAAiB,KACxC,EAAwBhB,mBAASD,EAAMkB,KAAKV,SAAQ,mBAA7CU,EAAI,KAAEC,EAAO,KACpB,EAA0BlB,oBAAS,GAAM,mBAAlCmB,EAAK,KAAEC,EAAQ,KACtB,EAAwBpB,oBAAS,GAAM,mBAAhCqB,EAAI,KAAEC,EAAO,KACpB,EAA0BtB,mBAAS,GAAE,mBAA9BuB,EAAK,KAAEC,EAAQ,KAEhBC,EAAaC,iBAAO,MACpBC,EAAaD,iBAAO,SAM1BE,qBAAU,WAuBRC,SAASC,iBAAiB,WAtB1B,SAAwBC,GACJ,YAAdA,EAAMC,KAA4C,YAAvBL,EAAWM,SACxCnB,EAAY,SACZa,EAAWM,QAAU,SACE,cAAdF,EAAMC,KAA8C,UAAvBL,EAAWM,SACjDnB,EAAY,WACZa,EAAWM,QAAU,WAEP,cAAdF,EAAMC,KACiB,aAAvBL,EAAWM,SAEXnB,EAAY,WACZa,EAAWM,QAAU,WAEP,eAAdF,EAAMC,KACiB,YAAvBL,EAAWM,UAEXnB,EAAY,YACZa,EAAWM,QAAU,WAEzB,GAGF,GAAG,IAEHL,qBAAU,WACRM,GAAkB1B,EAAWG,GAC7BwB,GAAiB3B,GACjB,IAAI4B,EAAeC,EAAgBtB,EAAgBF,GAC/CyB,EAAW,KAmBf,OAlBKjB,GAAQF,IACXmB,EAAWC,EACTnC,EACAI,EACAG,EACAyB,EACAnB,GAGFQ,EAAWQ,QAAUO,YAAW,WAC9BxB,EAAkBoB,GAClB3B,EAAa6B,EAASG,SACtB7B,EAAa0B,EAASI,SACtBxB,EAAQoB,EAASK,SACjBtC,EAAaiC,EAASnC,KACxB,GAAG,MAGE,WACLyC,aAAanB,EAAWQ,QAC1B,CACF,GAAG,CAAC7B,EAAWe,IAEf,IAAMoB,EAAoB,SACxBM,EACAC,EACAC,EACAC,EACAC,GAEA,IAKIR,EALEtC,EAAOV,EAASoD,GAChBvC,EAAOwC,EAASvC,QAChBG,EAAOjB,EAASsD,GAChB9B,EAAOgC,EAAS1C,QAChB2C,EAAYC,EAAc7C,EAAMW,GAEtC,OAAQ+B,GACN,IAAK,KACHP,EAAU,CAACnC,EAAK,GAAK,EAAGA,EAAK,IAC7B,MAEF,IAAK,OACHmC,EAAU,CAACnC,EAAK,GAAK,EAAGA,EAAK,IAC7B,MAEF,IAAK,OACHmC,EAAU,CAACnC,EAAK,GAAIA,EAAK,GAAK,GAC9B,MAEF,IAAK,QACHmC,EAAU,CAACnC,EAAK,GAAIA,EAAK,GAAK,GAIlCI,EAAK0C,QAAQ9C,GACb,IAAI+C,EAAW,KACVH,EAGH1B,GAAS,SAAC8B,GAAS,OAAKA,EAAY,CAAC,IAFrCD,EAAW3C,EAAK6C,MAIlB,IAAIb,EAAUhC,EACdP,EAAKsC,EAAQ,IAAIA,EAAQ,IAAM,EAAE,IACT,EAMpBE,EAP6B,cAChBD,GAAO,IAAxB,2BAA0B,CAAC,IAAlBc,EAAI,QACXrD,EAAKqD,EAAK,IAAIA,EAAK,IAAM,CAC3B,CAAC,+BAWD,OAViB,OAAbH,IACFlD,EAAKkD,EAAS,IAAIA,EAAS,IAAM,GAG/BH,EAEF/C,GADAwC,EAAUc,EAAgBtD,IACb,IAAIwC,EAAQ,IAAM,EAE/BA,EAAU1B,EAEL,CACLwB,UACAC,UACAvC,OACAwC,UAEJ,EAEMN,EAAkB,SAACqB,EAAeC,GACtC,IAAIvB,EACJ,OAAQuB,GACN,IAAK,QAEDvB,EADoB,SAAlBsB,EACa,KAEA,OAEjB,MAEF,IAAK,UAEDtB,EADoB,OAAlBsB,EACa,OAEA,KAEjB,MAEF,IAAK,UAEDtB,EADoB,UAAlBsB,EACa,OAEA,QAEjB,MAEF,IAAK,WAEDtB,EADoB,SAAlBsB,EACa,QAEA,OAKrB,OAAOtB,CACT,EAEMe,EAAgB,SAAC7C,EAAMW,GAC3B,OAAOX,EAAKsD,OAAM,SAACC,EAAMC,GACvB,OAAOD,IAAS5C,EAAK6C,EACvB,GACF,EAEML,EAAkB,SAACtD,GAEvB,IADA,IAAIwC,IACS,CACX,IAAIoB,EAAI,EAAIC,KAAKC,MAAMD,KAAKE,UAAYhE,EAAa,IACjDiE,EAAI,EAAIH,KAAKC,MAAMD,KAAKE,UAAYjE,EAAY,IACpD,GAAmB,IAAfE,EAAK4D,GAAGI,GAAZ,CACExB,EAAU,CAACoB,EAAGI,GAIhB,KADA,CAEF,CACA,OAAOxB,CACT,EAEMR,GAAmB,SAAC7B,GAEV,IAAZA,EAAK,IACLA,EAAK,KAAOJ,EAAa,GACb,IAAZI,EAAK,IACLA,EAAK,KAAOL,EAAY,GAExBqB,GAAQ,EAEZ,EAEMY,GAAoB,SAAC5B,EAAMI,GAC/BA,EAAK0D,SAAQ,SAACZ,GACRA,EAAK,KAAOlD,EAAK,IAAMkD,EAAK,KAAOlD,EAAK,IAC1CgB,GAAQ,EAEZ,GACF,EAQA,OACE,sBAAK+C,UAAU,kBAAiB,UAC5BlD,EAMA,gCACG,IACAE,EACC,sBAAKgD,UAAU,OAAM,UACnB,4BAAG,cACH,4BAAG,gBACH,4BAAI9C,IACJ,wBAAQ+C,QArBE,WACpBlD,GAAS,GACTE,GAAQ,GACRvB,EAAMwE,aAAY,EACpB,EAiB2C,SAAC,kBAGlC,qBACEF,UAAW,iBACXG,MAAO,CAAEC,oBAAoB,UAAD,OAAYxE,EAAS,WAAW,SAE3DG,EACEsE,KAAI,SAACC,EAAOC,GACX,OAAOD,EAAMD,KAAI,SAACG,EAAOC,GACvB,OAAQD,GACN,KAAK,EACH,OACE,qBAEER,UAAU,qBAAmB,WADpBO,EAAM,aAAKE,IAI1B,KAAK,EACH,OACE,qBAEET,UAAU,oBAAkB,WADnBO,EAAM,aAAKE,IAI1B,KAAK,EACH,OACE,qBAEET,UAAU,oBAAkB,WADnBO,EAAM,aAAKE,IAI1B,QACE,OACE,qBAEET,UAAU,cAAY,WADbO,EAAM,aAAKE,IAK9B,GACF,IACCC,SAAQ,SAAClB,GACR,OAAOA,CACT,SAxDR,sBAAKQ,UAAU,OAAM,UACnB,4BAAG,yBACH,wBAAQC,QAjNI,WAClBlD,GAAS,EACX,EA+MqC,SAAC,aA2DjCD,IAAUE,GACT,sBAAKgD,UAAU,QAAO,UACpB,4BAAG,WACH,4BAAI9C,SAKd,C,MCxLeyD,MAhHf,WACE,MAAkChF,mBAAS,MAAK,mBAAzCC,EAAS,KAAEgF,EAAY,KAC9B,EAAoCjF,mBAAS,KAAI,mBAA1CE,EAAU,KAAEgF,EAAa,KAChC,EAAkClF,oBAAS,GAAM,mBAA1CmF,EAAS,KAAEC,EAAY,KAC9B,EAAgDpF,mBAAS,MAAK,mBAAvDqF,EAAgB,KAAEC,EAAmB,KAC5C,EAAgDtF,mBAAS,MAAK,mBAAvDuF,EAAgB,KAAEC,EAAmB,KAC5C,EAAsCxF,mBAAS,MAAK,mBAA7CyF,EAAW,KAAEC,EAAc,KAClC,EAAsC1F,mBAAS,CAAC,KAAI,mBAA7C2F,EAAW,KAAEC,EAAc,KAE5BC,EAAWnE,iBAAO,MAoClBoE,EAAuB,SAACC,GAC5B,IAAIC,EAAQD,EAAI,GAAGE,OACfC,EAASH,EAAIE,OACbN,EAAcI,EAAIxF,QAClB8E,EAAmB,CACrBrB,KAAKC,MAAMD,KAAKmC,MAAMD,EAAS,GAAK,GACpClC,KAAKC,MAAMD,KAAKmC,MAAMH,EAAQ,GAAK,IAErCL,EAAYN,EAAiB,IAAIA,EAAiB,IAAM,EAExD,IADA,IAAIE,EAAmB,GACda,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,IAAIC,EAAgB,CAAChB,EAAiB,GAAKe,EAAGf,EAAiB,IAC/DE,EAAiBe,KAAKD,EACxB,CACA,cAAqBd,EAAgB,eAAE,CAAlC,IAAIgB,EAAQ,KACfZ,EAAYY,EAAS,IAAIA,EAAS,IAAM,CAC1C,CAEA,IADA,IAAId,EAAc,KACL,CACX,IAAI1B,EAAI,EAAIC,KAAKC,MAAMD,KAAKE,UAAYgC,EAAS,IAC7C/B,EAAI,EAAIH,KAAKC,MAAMD,KAAKE,UAAY8B,EAAQ,IAChD,GAA0B,IAAtBL,EAAY5B,GAAGI,GAAnB,CACEwB,EAAY5B,GAAGI,GAAK,EACpBsB,EAAc,CAAC1B,EAAGI,GAIpB,KADA,CAEF,CACA,MAAO,CACLkB,mBACAE,mBACAE,cACAE,cAEJ,EAEA,OACE,qBAAKtB,UAAU,MAAK,SAChBc,EAcA,cAACrF,EAAK,CACJK,KAAMwF,EACNrF,KAAM+E,EACN3E,KAAM6E,EACNtE,KAAMwE,EACNxF,UAAWuG,OAAOC,SAASxG,GAAa,EACxCC,WAAYsG,OAAOC,SAASvG,GAAc,EAC1CqE,YAAaa,IApBf,sBAAKf,UAAU,OAAM,UACnB,4BAAG,8CACH,4BAAG,WACH,uBAAOqC,KAAK,SAASC,MAAO1G,EAAW2G,SAnDrB,SAAC7E,GACzBkD,EAAalD,EAAM8E,OAAOF,MAC5B,IAkDQ,4BAAG,YACH,uBACED,KAAK,SACLC,MAAOzG,EACP0G,SApDiB,SAAC7E,GAC1BmD,EAAcnD,EAAM8E,OAAOF,MAC7B,IAoDQ,wBAAQrC,QApFQ,WACtB,IAAM0B,EAAQQ,OAAOC,SAASxG,GACxBiG,EAASM,OAAOC,SAASvG,GAC/B,KAAI8F,EAAQ,IAAME,EAAS,GAAKF,EAAQ,IAAME,EAAS,IAAvD,CAGAtD,aAAaiD,EAAS5D,SAEtB,IADA,IAAM6E,EAAY,GACTV,EAAI,EAAGA,EAAIF,EAAS,EAAGE,IAAK,CACnCU,EAAUR,KAAK,IACf,IAAK,IAAIS,EAAI,EAAGA,EAAIf,EAAQ,EAAGe,IACzBX,GAAK,GAAKA,GAAKF,GAAUa,GAAK,GAAKA,GAAKf,EAC1Cc,EAAUV,GAAGE,KAAK,GAElBQ,EAAUV,GAAGE,KAAK,EAGxB,CACA,IAAIU,EAAWlB,EAAqBgB,GACpCxB,EAAoB0B,EAAS3B,kBAC7BG,EAAoBwB,EAASzB,kBAC7BG,EAAesB,EAASvB,aACxBG,EAAeoB,EAASrB,aACxBP,GAAa,EAlBb,CAmBF,EA4DyC,SAAC,iBAe5C,EC5GM6B,EAAcpF,SAASqF,eAAe,QAC/BC,qBAAWF,GAEnBG,OACH,cAAC,aAAU,UACT,cAAC,EAAG,M","file":"static/js/main.39137267.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\r\nimport \"./snake.css\";\r\n\r\n//deep copy arrays, suitable for primitives like in the grid\r\nfunction deepCopy(array) {\r\n  return JSON.parse(JSON.stringify(array));\r\n}\r\n\r\nexport default function Snake(props) {\r\n  const [gridWidth, setGridWidth] = useState(props.gridWidth);\r\n  const [gridHeight, setGridHeight] = useState(props.gridHeight);\r\n  const [gridState, setGridState] = useState(deepCopy(props.grid));\r\n  const [snakeHead, setSnakeHead] = useState(props.head.slice());\r\n  const [snakePath, setSnakePath] = useState(deepCopy(props.path));\r\n  const [keyPress, setKeyPress] = useState(\"keyUp\");\r\n  const [snakeDirection, setSnakeDirection] = useState(\"up\");\r\n  const [food, setFood] = useState(props.food.slice());\r\n  const [start, setStart] = useState(false);\r\n  const [loss, setLoss] = useState(false);\r\n  const [score, setScore] = useState(0);\r\n\r\n  const timeoutRef = useRef(null);\r\n  const prevKeyRef = useRef(\"keyUp\");\r\n\r\n  const handleStart = () => {\r\n    setStart(true);\r\n  };\r\n\r\n  useEffect(() => {\r\n    function handleKeyPress(event) {\r\n      if (event.key === \"ArrowUp\" && prevKeyRef.current !== \"keyDown\") {\r\n        setKeyPress(\"keyUp\");\r\n        prevKeyRef.current = \"keyUp\";\r\n      } else if (event.key === \"ArrowDown\" && prevKeyRef.current !== \"keyUp\") {\r\n        setKeyPress(\"keyDown\");\r\n        prevKeyRef.current = \"keyDown\";\r\n      } else if (\r\n        event.key === \"ArrowLeft\" &&\r\n        prevKeyRef.current !== \"keyRight\"\r\n      ) {\r\n        setKeyPress(\"keyLeft\");\r\n        prevKeyRef.current = \"keyLeft\";\r\n      } else if (\r\n        event.key === \"ArrowRight\" &&\r\n        prevKeyRef.current !== \"keyLeft\"\r\n      ) {\r\n        setKeyPress(\"keyRight\");\r\n        prevKeyRef.current = \"keyRight\";\r\n      }\r\n    }\r\n\r\n    document.addEventListener(\"keydown\", handleKeyPress);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    checkSnakeContact(snakeHead, snakePath);\r\n    checkWallContact(snakeHead);\r\n    let newDirection = chooseDirection(snakeDirection, keyPress);\r\n    let newState = null;\r\n    if (!loss && start) {\r\n      newState = generateNextState(\r\n        gridState,\r\n        snakeHead,\r\n        snakePath,\r\n        newDirection,\r\n        food\r\n      );\r\n\r\n      timeoutRef.current = setTimeout(() => {\r\n        setSnakeDirection(newDirection);\r\n        setSnakeHead(newState.newHead);\r\n        setSnakePath(newState.newPath);\r\n        setFood(newState.newFood);\r\n        setGridState(newState.grid);\r\n      }, 350);\r\n    }\r\n\r\n    return () => {\r\n      clearTimeout(timeoutRef.current);\r\n    };\r\n  }, [gridState, start]);\r\n\r\n  const generateNextState = (\r\n    prevGrid,\r\n    prevHead,\r\n    prevPath,\r\n    direction,\r\n    prevFood\r\n  ) => {\r\n    const grid = deepCopy(prevGrid);\r\n    const head = prevHead.slice();\r\n    const path = deepCopy(prevPath);\r\n    const food = prevFood.slice();\r\n    const foodEaten = handleEatFood(head, food);\r\n    let newHead;\r\n    switch (direction) {\r\n      case \"up\": {\r\n        newHead = [head[0] - 1, head[1]];\r\n        break;\r\n      }\r\n      case \"down\": {\r\n        newHead = [head[0] + 1, head[1]];\r\n        break;\r\n      }\r\n      case \"left\": {\r\n        newHead = [head[0], head[1] - 1];\r\n        break;\r\n      }\r\n      case \"right\": {\r\n        newHead = [head[0], head[1] + 1];\r\n        break;\r\n      }\r\n    }\r\n    path.unshift(head);\r\n    let lastCell = null;\r\n    if (!foodEaten) {\r\n      lastCell = path.pop();\r\n    } else {\r\n      setScore((prevScore) => prevScore + 1);\r\n    }\r\n    let newPath = path;\r\n    grid[newHead[0]][newHead[1]] = 1;\r\n    for (let cell of newPath) {\r\n      grid[cell[0]][cell[1]] = 1;\r\n    }\r\n    if (lastCell !== null) {\r\n      grid[lastCell[0]][lastCell[1]] = 0;\r\n    }\r\n    let newFood;\r\n    if (foodEaten) {\r\n      newFood = generateNewFood(grid);\r\n      grid[newFood[0]][newFood[1]] = 2;\r\n    } else {\r\n      newFood = food;\r\n    }\r\n    return {\r\n      newHead,\r\n      newPath,\r\n      grid,\r\n      newFood\r\n    };\r\n  };\r\n\r\n  const chooseDirection = (prevDirection, arrow) => {\r\n    let newDirection;\r\n    switch (arrow) {\r\n      case \"keyUp\": {\r\n        if (prevDirection !== \"down\") {\r\n          newDirection = \"up\";\r\n        } else {\r\n          newDirection = \"down\";\r\n        }\r\n        break;\r\n      }\r\n      case \"keyDown\": {\r\n        if (prevDirection !== \"up\") {\r\n          newDirection = \"down\";\r\n        } else {\r\n          newDirection = \"up\";\r\n        }\r\n        break;\r\n      }\r\n      case \"keyLeft\": {\r\n        if (prevDirection !== \"right\") {\r\n          newDirection = \"left\";\r\n        } else {\r\n          newDirection = \"right\";\r\n        }\r\n        break;\r\n      }\r\n      case \"keyRight\": {\r\n        if (prevDirection !== \"left\") {\r\n          newDirection = \"right\";\r\n        } else {\r\n          newDirection = \"left\";\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    return newDirection;\r\n  };\r\n\r\n  const handleEatFood = (head, food) => {\r\n    return head.every((item, index) => {\r\n      return item === food[index];\r\n    });\r\n  };\r\n\r\n  const generateNewFood = (grid) => {\r\n    let newFood;\r\n    while (true) {\r\n      let y = 1 + Math.floor(Math.random() * (gridHeight - 2));\r\n      let x = 1 + Math.floor(Math.random() * (gridWidth - 2));\r\n      if (grid[y][x] === 0) {\r\n        newFood = [y, x];\r\n      } else {\r\n        continue;\r\n      }\r\n      break;\r\n    }\r\n    return newFood;\r\n  };\r\n\r\n  const checkWallContact = (head) => {\r\n    if (\r\n      head[0] === 1 ||\r\n      head[0] === gridHeight - 2 ||\r\n      head[1] === 1 ||\r\n      head[1] === gridWidth - 2\r\n    ) {\r\n      setLoss(true);\r\n    }\r\n  };\r\n\r\n  const checkSnakeContact = (head, path) => {\r\n    path.forEach((cell) => {\r\n      if (cell[0] === head[0] && cell[1] === head[1]) {\r\n        setLoss(true);\r\n      }\r\n    });\r\n  };\r\n\r\n  const handleRestart = () => {\r\n    setStart(false);\r\n    setLoss(false);\r\n    props.gameRestart(false);\r\n  };\r\n\r\n  return (\r\n    <div className=\"snake-container\">\r\n      {!start ? (\r\n        <div className=\"menu\">\r\n          <p>Press start to begin</p>\r\n          <button onClick={handleStart}>Start</button>\r\n        </div>\r\n      ) : (\r\n        <div>\r\n          {\" \"}\r\n          {loss ? (\r\n            <div className=\"menu\">\r\n              <p>GAME OVER</p>\r\n              <p>Your score:</p>\r\n              <p>{score}</p>\r\n              <button onClick={handleRestart}>Try again?</button>\r\n            </div>\r\n          ) : (\r\n            <div\r\n              className={\"grid-container\"}\r\n              style={{ gridTemplateColumns: `repeat(${gridWidth}, 1fr)` }}\r\n            >\r\n              {gridState\r\n                .map((itemH, indexH) => {\r\n                  return itemH.map((itemW, indexW) => {\r\n                    switch (itemW) {\r\n                      case 1:\r\n                        return (\r\n                          <div\r\n                            key={`h${indexH} w${indexW}`}\r\n                            className=\"cell-raised snake\"\r\n                          ></div>\r\n                        );\r\n                      case 2:\r\n                        return (\r\n                          <div\r\n                            key={`h${indexH} w${indexW}`}\r\n                            className=\"cell-raised food\"\r\n                          ></div>\r\n                        );\r\n                      case 3:\r\n                        return (\r\n                          <div\r\n                            key={`h${indexH} w${indexW}`}\r\n                            className=\"cell-raised wall\"\r\n                          ></div>\r\n                        );\r\n                      default:\r\n                        return (\r\n                          <div\r\n                            key={`h${indexH} w${indexW}`}\r\n                            className=\"cell empty\"\r\n                          ></div>\r\n                        );\r\n                    }\r\n                  });\r\n                })\r\n                .flatMap((item) => {\r\n                  return item;\r\n                })}\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n      {start && !loss && (\r\n        <div className=\"score\">\r\n          <p>SCORE:</p>\r\n          <p>{score}</p>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","import React, { useState, useRef } from \"react\";\nimport Snake from \"./Snake.js\";\nimport \"./app.css\";\n\nfunction App() {\n  const [gridWidth, setGridWidth] = useState(\"12\");\n  const [gridHeight, setGridHeight] = useState(\"9\");\n  const [gameStart, setGameStart] = useState(false);\n  const [initialSnakeHead, setInitialSnakeHead] = useState(null);\n  const [initialSnakePath, setInitialSnakePath] = useState(null);\n  const [initialFood, setInitialFood] = useState(null);\n  const [initialGrid, setInitialGrid] = useState([[]]);\n\n  const errorRef = useRef(null);\n\n  const handleGameStart = () => {\n    const width = Number.parseInt(gridWidth);\n    const height = Number.parseInt(gridHeight);\n    if (width < 12 || height < 9 || width > 30 || height > 30) {\n      return;\n    }\n    clearTimeout(errorRef.current);\n    const gridArray = [];\n    for (let i = 0; i < height + 2; i++) {\n      gridArray.push([]);\n      for (let j = 0; j < width + 2; j++) {\n        if (i <= 1 || i >= height || j <= 1 || j >= width) {\n          gridArray[i].push(3);\n        } else {\n          gridArray[i].push(0);\n        }\n      }\n    }\n    let startObj = setStartingPositions(gridArray);\n    setInitialSnakeHead(startObj.initialSnakeHead);\n    setInitialSnakePath(startObj.initialSnakePath);\n    setInitialFood(startObj.initialFood);\n    setInitialGrid(startObj.initialGrid);\n    setGameStart(true);\n  };\n\n  const handleWidthChange = (event) => {\n    setGridWidth(event.target.value);\n  };\n\n  const handleHeightChange = (event) => {\n    setGridHeight(event.target.value);\n  };\n\n  const setStartingPositions = (arr) => {\n    let width = arr[0].length;\n    let height = arr.length;\n    let initialGrid = arr.slice();\n    let initialSnakeHead = [\n      Math.floor(Math.round(height / 2) - 2),\n      Math.floor(Math.round(width / 3) - 1)\n    ];\n    initialGrid[initialSnakeHead[0]][initialSnakeHead[1]] = 1;\n    let initialSnakePath = [];\n    for (let i = 1; i < 3; i++) {\n      let snakePathCell = [initialSnakeHead[0] + i, initialSnakeHead[1]];\n      initialSnakePath.push(snakePathCell);\n    }\n    for (let pathCell of initialSnakePath) {\n      initialGrid[pathCell[0]][pathCell[1]] = 1;\n    }\n    let initialFood = [];\n    while (true) {\n      let y = 1 + Math.floor(Math.random() * (height - 1));\n      let x = 1 + Math.floor(Math.random() * (width - 1));\n      if (initialGrid[y][x] === 0) {\n        initialGrid[y][x] = 2;\n        initialFood = [y, x];\n      } else {\n        continue;\n      }\n      break;\n    }\n    return {\n      initialSnakeHead,\n      initialSnakePath,\n      initialFood,\n      initialGrid\n    };\n  };\n\n  return (\n    <div className=\"App\">\n      {!gameStart ? (\n        <div className=\"menu\">\n          <p>Enter grid size (between 12x9 and 30x30):</p>\n          <p>Width:</p>\n          <input type=\"number\" value={gridWidth} onChange={handleWidthChange} />\n          <p>Height:</p>\n          <input\n            type=\"number\"\n            value={gridHeight}\n            onChange={handleHeightChange}\n          />\n          <button onClick={handleGameStart}>Continue</button>\n        </div>\n      ) : (\n        <Snake\n          grid={initialGrid}\n          head={initialSnakeHead}\n          path={initialSnakePath}\n          food={initialFood}\n          gridWidth={Number.parseInt(gridWidth) + 2}\n          gridHeight={Number.parseInt(gridHeight) + 2}\n          gameRestart={setGameStart}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default App;\n","import { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport \"./index.css\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nconst root = createRoot(rootElement);\n\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n"],"sourceRoot":""}